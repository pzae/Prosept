## Prosept. Cоздание сервиса для полуавтоматической разметки товаров.

### Группа DS команды №12 

**Задача: разработка решения, которое автоматизирует процесс сопоставления товаров заказчика с размещаемыми товарами дилеров.**

За выполнение поставленной задачи со стороны DS отвечали Александр (TL), Милана и Рената. Использованный язык программирования - **python**.

### Инструкция к репозиторию

* `Prosept_script.py` - скрипт для сборки докера.
  
В папке `project_description`:
* `Prosept_script.ipynb` - скрипт, записанный в тетрадке Jupyter Notebook. 
* `Prosept_project.ipynb` - тетрадка с подробным описание хода выполнения проекта.
* `requirements.txt` - файл для создания докера
* `Dockerfile` - файл для создания докера

### Описание решения

За основную гипотезу выбрано предположение о том, что названий товаров достаточно для получения мэтча с приемлемой точностью. Для реализации этой гипотезы выбран метод `cosine_similarity`, применённый к векторам названий, полученным с помощью `TfidfVectorizer()`. Сопоставляются вектора столбцов `df_dealerprice.product_name` и `df_product.name`. Остальные фичи не используются. Необходимость их добавления в проект будет рассмотрена по итогу реализации данного решения и его оценки.

### Проделанная работа

Милана начала работу с получения эмбеддингов с помощью предобученной модели `BERT`. Однако было принято решение отложить это направление в пользу наиболее актуальных задач: предобработки названий, лемматизации, исправления ошибок в названиях. Сейчас вернулась к `tiny-BERT`. Если метрика значительно вырастет (10%+) при некритичном увеличении объёма проекта за счёт дополнительно подключаемых библиотек, то перейдём к этому варианту.
Рената решила попробовать применить метод `ALS`, который по итогу командным решением признали не целесообразным. После этого продолжила работу Миланы по предобработке текста. Её подход добавил 11% точности к показаниям нашей метрики.
Александр прорабатывал бэйзлайн решения: метод `cosine_similarity` для векторов, рассчитанных с помощью `TfidfVectorizer`. Разработаны функции:
1. `preprocess` для препроцессинга текста на основе кода, составленного совместно Миланой и Ренатой. Представлена в коде скрипта. В тетрадке сохранена разбивка на мелкие функции для удобства чтения и дальнейшей модернизации.
2. Функция предсказания `prediction`, которая рассчитывает `cos_sim` для всех уникальных пар `название дилера - название заказчика` 
3. Функция метрики `metric`. На данный момент учитывает только попадание правильных названий от заказчика в топ `n` пока без учёта позиции. 
4. Функция `first_n_no_match` для изучения неправильно полученных мэтчей. Не входит в финальный скрипт.

На данный момент освоен `Docker`, упакованный в контейнер код выполняется корректно. После ревью приступим к интеграции докер контейнера с `API`. Также будут выбраны входные и выходные точки.

### Результаты

На данный момент наилучший результат: 
- **87%** правильных названий продуктов от заказчика попадают в топ-5 предложенных <br>
и <br>
- **1.7** секунды - время выполнения в тетрадке функции предсказания - самой ресурсоёмкой функции - для всего набора данных.

### Выводы и планы

Выбранная базовая гипотеза подтвердилась, предложенный для её реализации метод дал отличные результаты. При этом в используемых названиях от заказчика и дилеров всё еще есть недостатки, ликвидируя которые можно дополнительно поднять точность мэтчей.

В ходе выполнения проекта релизована предобработка данных. Разработан метод сопоставления топ `n` названий заказчиков названиям дилеров. Получены отличная скорость выполнения кода и отличное значение метрики. В будущем необходимо:

1. проработать вопрос об одинаковых названиях с разными `id`;
2. оптимизировать блок кода с предобработкой текста;
3. ввести метрику `mean_reciprocal_rank`;
4. исследовать случаи, когда сходство = 0;
5. добавить новые слова к функции добавления пробелов;
6. применить `prediction` к эмбедингам от `tiny-BERT`.

### Инструкция к коду

1. Указать в переменной `path_to_dir` путь к директории с входными `csv` файлами. В нашем проекте это `../data/`.
2. Запустить код.
3. На выходе получить файлы `my_data.csv` и `my_data` в формате `JSON`. Также выводится результат выполнения функции `metric`, который должен быть равен `0.8687`.

На данный момент не реализованы входные и выходные точки, однако такой сценарий работы скрипта согласован с бэком.

